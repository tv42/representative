// Code generated by github.com/tv42/becky -- DO NOT EDIT.

package static

var _ = addAsset(asset{Name: "playground.js", Content: "" +
	"// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n/*\nIn the absence of any formal way to specify interfaces in JavaScript,\nhere's a skeleton implementation of a playground transport.\n\n        function Transport() {\n                // Set up any transport state (eg, make a websocket connection).\n                return {\n                        Run: function(body, output, options) {\n                                // Compile and run the program 'body' with 'options'.\n\t\t\t\t// Call the 'output' callback to display program output.\n                                return {\n                                        Kill: function() {\n                                                // Kill the running program.\n                                        }\n                                };\n                        }\n                };\n        }\n\n\t// The output callback is called multiple times, and each time it is\n\t// passed an object of this form.\n        var write = {\n                Kind: 'string', // 'start', 'stdout', 'stderr', 'end'\n                Body: 'string'  // content of write or end status message\n        }\n\n\t// The first call must be of Kind 'start' with no body.\n\t// Subsequent calls may be of Kind 'stdout' or 'stderr'\n\t// and must have a non-null Body string.\n\t// The final call should be of Kind 'end' with an optional\n\t// Body string, signifying a failure (\"killed\", for example).\n\n\t// The output callback must be of this form.\n\t// See PlaygroundOutput (below) for an implementation.\n        function outputCallback(write) {\n        }\n*/\n\n// HTTPTransport is the default transport.\n// enableVet enables running vet if a program was compiled and ran successfully.\n// If vet returned any errors, display them before the output of a program.\nfunction HTTPTransport(enableVet) {\n\t'use strict';\n\n\tfunction playback(output, data) {\n\t\t// Backwards compatibility: default values do not affect the output.\n\t\tvar events = data.Events || [];\n\t\tvar errors = data.Errors || \"\";\n\t\tvar status = data.Status || 0;\n\t\tvar isTest = data.IsTest || false;\n\t\tvar testsFailed = data.TestsFailed || 0;\n\n\t\tvar timeout;\n\t\toutput({Kind: 'start'});\n\t\tfunction next() {\n\t\t\tif (!events || events.length === 0) {\n\t\t\t\tif (isTest) {\n\t\t\t\t\tif (testsFailed > 0) {\n\t\t\t\t\t\toutput({Kind: 'system', Body: '\\n'+testsFailed+' test'+(testsFailed>1?'s':'')+' failed.'});\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutput({Kind: 'system', Body: '\\nAll tests passed.'});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (status > 0) {\n\t\t\t\t\t\toutput({Kind: 'end', Body: 'status ' + status + '.'});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (errors !== \"\") {\n\t\t\t\t\t\t\t// errors are displayed only in the case of timeout.\n\t\t\t\t\t\t\toutput({Kind: 'end', Body: errors + '.'});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toutput({Kind: 'end'});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar e = events.shift();\n\t\t\tif (e.Delay === 0) {\n\t\t\t\toutput({Kind: e.Kind, Body: e.Message});\n\t\t\t\tnext();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttimeout = setTimeout(function() {\n\t\t\t\toutput({Kind: e.Kind, Body: e.Message});\n\t\t\t\tnext();\n\t\t\t}, e.Delay / 1000000);\n\t\t}\n\t\tnext();\n\t\treturn {\n\t\t\tStop: function() {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction error(output, msg) {\n\t\toutput({Kind: 'start'});\n\t\toutput({Kind: 'stderr', Body: msg});\n\t\toutput({Kind: 'end'});\n\t}\n\n\tfunction buildFailed(output, msg) {\n\t\toutput({Kind: 'start'});\n\t\toutput({Kind: 'stderr', Body: msg});\n\t\toutput({Kind: 'system', Body: '\\nGo build failed.'});\n\t}\n\n\tvar seq = 0;\n\treturn {\n\t\tRun: function(body, output, options) {\n\t\t\tseq++;\n\t\t\tvar cur = seq;\n\t\t\tvar playing;\n\t\t\t$.ajax('https://play.golang.org/compile', {\n\t\t\t\ttype: 'POST',\n\t\t\t\tdata: {'version': 2, 'body': body, 'withVet': enableVet},\n\t\t\t\tdataType: 'json',\n\t\t\t\tsuccess: function(data) {\n\t\t\t\t\tif (seq != cur) return;\n\t\t\t\t\tif (!data) return;\n\t\t\t\t\tif (playing != null) playing.Stop();\n\t\t\t\t\tif (data.Errors) {\n\t\t\t\t\t\tif (data.Errors === 'process took too long') {\n\t\t\t\t\t\t\t// Playback the output that was captured before the timeout.\n\t\t\t\t\t\t\tplaying = playback(output, data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbuildFailed(output, data.Errors);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (!data.Events) {\n\t\t\t\t\t\tdata.Events = [];\n\t\t\t\t\t}\n\t\t\t\t\tif (data.VetErrors) {\n\t\t\t\t\t\t// Inject errors from the vet as the first events in the output.\n\t\t\t\t\t\tdata.Events.unshift({Message: 'Go vet exited.\\n\\n', Kind: 'system', Delay: 0});\n\t\t\t\t\t\tdata.Events.unshift({Message: data.VetErrors, Kind: 'stderr', Delay: 0});\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!enableVet || data.VetOK || data.VetErrors) {\n\t\t\t\t\t\tplaying = playback(output, data);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// In case the server support doesn't support\n\t\t\t\t\t// compile+vet in same request signaled by the\n\t\t\t\t\t// 'withVet' parameter above, also try the old way.\n\t\t\t\t\t// TODO: remove this when it falls out of use.\n\t\t\t\t\t// It is 2019-05-13 now.\n\t\t\t\t\t$.ajax(\"https://play.golang.org/vet\", {\n\t\t\t\t\t\tdata: {\"body\": body},\n\t\t\t\t\t\ttype: \"POST\",\n\t\t\t\t\t\tdataType: \"json\",\n\t\t\t\t\t\tsuccess: function(dataVet) {\n\t\t\t\t\t\t\tif (dataVet.Errors) {\n\t\t\t\t\t\t\t\t// inject errors from the vet as the first events in the output\n\t\t\t\t\t\t\t\tdata.Events.unshift({Message: 'Go vet exited.\\n\\n', Kind: 'system', Delay: 0});\n\t\t\t\t\t\t\t\tdata.Events.unshift({Message: dataVet.Errors, Kind: 'stderr', Delay: 0});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tplaying = playback(output, data);\n\t\t\t\t\t\t},\n\t\t\t\t\t\terror: function() {\n\t\t\t\t\t\t\tplaying = playback(output, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\terror: function() {\n\t\t\t\t\terror(output, 'Error communicating with remote server.');\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tKill: function() {\n\t\t\t\t\tif (playing != null) playing.Stop();\n\t\t\t\t\toutput({Kind: 'end', Body: 'killed'});\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n}\n\nfunction SocketTransport() {\n\t'use strict';\n\n\tvar id = 0;\n\tvar outputs = {};\n\tvar started = {};\n\tvar websocket;\n\tif (window.location.protocol == \"http:\") {\n\t\twebsocket = new WebSocket('ws://' + window.location.host + '/socket');\n\t} else if (window.location.protocol == \"https:\") {\n\t\twebsocket = new WebSocket('wss://' + window.location.host + '/socket');\n\t}\n\n\twebsocket.onclose = function() {\n\t\tconsole.log('websocket connection closed');\n\t};\n\n\twebsocket.onmessage = function(e) {\n\t\tvar m = JSON.parse(e.data);\n\t\tvar output = outputs[m.Id];\n\t\tif (output === null)\n\t\t\treturn;\n\t\tif (!started[m.Id]) {\n\t\t\toutput({Kind: 'start'});\n\t\t\tstarted[m.Id] = true;\n\t\t}\n\t\toutput({Kind: m.Kind, Body: m.Body});\n\t};\n\n\tfunction send(m) {\n\t\twebsocket.send(JSON.stringify(m));\n\t}\n\n\treturn {\n\t\tRun: function(body, output, options) {\n\t\t\tvar thisID = id+'';\n\t\t\tid++;\n\t\t\toutputs[thisID] = output;\n\t\t\tsend({Id: thisID, Kind: 'run', Body: body, Options: options});\n\t\t\treturn {\n\t\t\t\tKill: function() {\n\t\t\t\t\tsend({Id: thisID, Kind: 'kill'});\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n}\n\nfunction PlaygroundOutput(el) {\n\t'use strict';\n\n\treturn function(write) {\n\t\tif (write.Kind == 'start') {\n\t\t\tel.innerHTML = '';\n\t\t\treturn;\n\t\t}\n\n\t\tvar cl = 'system';\n\t\tif (write.Kind == 'stdout' || write.Kind == 'stderr')\n\t\t\tcl = write.Kind;\n\n\t\tvar m = write.Body;\n\t\tif (write.Kind == 'end') {\n\t\t\tm = '\\nProgram exited' + (m?(': '+m):'.');\n\t\t}\n\n\t\tif (m.indexOf('IMAGE:') === 0) {\n\t\t\t// TODO(adg): buffer all writes before creating image\n\t\t\tvar url = 'data:image/png;base64,' + m.substr(6);\n\t\t\tvar img = document.createElement('img');\n\t\t\timg.src = url;\n\t\t\tel.appendChild(img);\n\t\t\treturn;\n\t\t}\n\n\t\t// ^L clears the screen.\n\t\tvar s = m.split('\\x0c');\n\t\tif (s.length > 1) {\n\t\t\tel.innerHTML = '';\n\t\t\tm = s.pop();\n\t\t}\n\n\t\tm = m.replace(/&/g, '&amp;');\n\t\tm = m.replace(/</g, '&lt;');\n\t\tm = m.replace(/>/g, '&gt;');\n\n\t\tvar needScroll = (el.scrollTop + el.offsetHeight) == el.scrollHeight;\n\n\t\tvar span = document.createElement('span');\n\t\tspan.className = cl;\n\t\tspan.innerHTML = m;\n\t\tel.appendChild(span);\n\n\t\tif (needScroll)\n\t\t\tel.scrollTop = el.scrollHeight - el.offsetHeight;\n\t};\n}\n\n(function() {\n  function lineHighlight(error) {\n    var regex = /prog.go:([0-9]+)/g;\n    var r = regex.exec(error);\n    while (r) {\n      $(\".lines div\").eq(r[1]-1).addClass(\"lineerror\");\n      r = regex.exec(error);\n    }\n  }\n  function highlightOutput(wrappedOutput) {\n    return function(write) {\n      if (write.Body) lineHighlight(write.Body);\n      wrappedOutput(write);\n    };\n  }\n  function lineClear() {\n    $(\".lineerror\").removeClass(\"lineerror\");\n  }\n\n  // opts is an object with these keys\n  //  codeEl - code editor element\n  //  outputEl - program output element\n  //  runEl - run button element\n  //  fmtEl - fmt button element (optional)\n  //  fmtImportEl - fmt \"imports\" checkbox element (optional)\n  //  shareEl - share button element (optional)\n  //  shareURLEl - share URL text input element (optional)\n  //  shareRedirect - base URL to redirect to on share (optional)\n  //  enableHistory - enable using HTML5 history API (optional)\n  //  transport - playground transport to use (default is HTTPTransport)\n  //  enableShortcuts - whether to enable shortcuts (Ctrl+S/Cmd+S to save) (default is false)\n  //  enableVet - enable running vet and displaying its errors\n  function playground(opts) {\n    var code = $(opts.codeEl);\n    var transport = opts['transport'] || new HTTPTransport(opts['enableVet']);\n    var running;\n\n    // autoindent helpers.\n    function insertTabs(n) {\n      // find the selection start and end\n      var start = code[0].selectionStart;\n      var end   = code[0].selectionEnd;\n      // split the textarea content into two, and insert n tabs\n      var v = code[0].value;\n      var u = v.substr(0, start);\n      for (var i=0; i<n; i++) {\n        u += \"\\t\";\n      }\n      u += v.substr(end);\n      // set revised content\n      code[0].value = u;\n      // reset caret position after inserted tabs\n      code[0].selectionStart = start+n;\n      code[0].selectionEnd = start+n;\n    }\n    function autoindent(el) {\n      var curpos = el.selectionStart;\n      var tabs = 0;\n      while (curpos > 0) {\n        curpos--;\n        if (el.value[curpos] == \"\\t\") {\n          tabs++;\n        } else if (tabs > 0 || el.value[curpos] == \"\\n\") {\n          break;\n        }\n      }\n      setTimeout(function() {\n        insertTabs(tabs);\n      }, 1);\n    }\n\n    // NOTE(cbro): e is a jQuery event, not a DOM event.\n    function handleSaveShortcut(e) {\n      if (e.isDefaultPrevented()) return false;\n      if (!e.metaKey && !e.ctrlKey) return false;\n      if (e.key != \"S\" && e.key != \"s\") return false;\n\n      e.preventDefault();\n\n      // Share and save\n      share(function(url) {\n        window.location.href = url + \".go?download=true\";\n      });\n\n      return true;\n    }\n\n    function keyHandler(e) {\n      if (opts.enableShortcuts && handleSaveShortcut(e)) return;\n\n      if (e.keyCode == 9 && !e.ctrlKey) { // tab (but not ctrl-tab)\n        insertTabs(1);\n        e.preventDefault();\n        return false;\n      }\n      if (e.keyCode == 13) { // enter\n        if (e.shiftKey) { // +shift\n          run();\n          e.preventDefault();\n          return false;\n        } if (e.ctrlKey) { // +control\n          fmt();\n          e.preventDefault();\n        } else {\n          autoindent(e.target);\n        }\n      }\n      return true;\n    }\n    code.unbind('keydown').bind('keydown', keyHandler);\n    var outdiv = $(opts.outputEl).empty();\n    var output = $('<pre/>').appendTo(outdiv);\n\n    function body() {\n      return $(opts.codeEl).val();\n    }\n    function setBody(text) {\n      $(opts.codeEl).val(text);\n    }\n    function origin(href) {\n      return (\"\"+href).split(\"/\").slice(0, 3).join(\"/\");\n    }\n\n    var pushedEmpty = (window.location.pathname == \"/\");\n    function inputChanged() {\n      if (pushedEmpty) {\n        return;\n      }\n      pushedEmpty = true;\n      $(opts.shareURLEl).hide();\n      window.history.pushState(null, \"\", \"/\");\n    }\n    function popState(e) {\n      if (e === null) {\n        return;\n      }\n      if (e && e.state && e.state.code) {\n        setBody(e.state.code);\n      }\n    }\n    var rewriteHistory = false;\n    if (window.history && window.history.pushState && window.addEventListener && opts.enableHistory) {\n      rewriteHistory = true;\n      code[0].addEventListener('input', inputChanged);\n      window.addEventListener('popstate', popState);\n    }\n\n    function setError(error) {\n      if (running) running.Kill();\n      lineClear();\n      lineHighlight(error);\n      output.empty().addClass(\"error\").text(error);\n    }\n    function loading() {\n      lineClear();\n      if (running) running.Kill();\n      output.removeClass(\"error\").text('Waiting for remote server...');\n    }\n    function run() {\n      loading();\n      running = transport.Run(body(), highlightOutput(PlaygroundOutput(output[0])));\n    }\n\n    function fmt() {\n      loading();\n      var data = {\"body\": body()};\n      if ($(opts.fmtImportEl).is(\":checked\")) {\n        data[\"imports\"] = \"true\";\n      }\n      $.ajax(\"https://play.golang.org/fmt\", {\n        data: data,\n        type: \"POST\",\n        dataType: \"json\",\n        success: function(data) {\n          if (data.Error) {\n            setError(data.Error);\n          } else {\n            setBody(data.Body);\n            setError(\"\");\n          }\n        }\n      });\n    }\n\n    var shareURL; // jQuery element to show the shared URL.\n    var sharing = false; // true if there is a pending request.\n    var shareCallbacks = [];\n    function share(opt_callback) {\n      if (opt_callback) shareCallbacks.push(opt_callback);\n\n      if (sharing) return;\n      sharing = true;\n\n      var sharingData = body();\n      $.ajax(\"https://play.golang.org/share\", {\n        processData: false,\n        data: sharingData,\n        type: \"POST\",\n        contentType: \"text/plain; charset=utf-8\",\n        complete: function(xhr) {\n          sharing = false;\n          if (xhr.status != 200) {\n            alert(\"Server error; try again.\");\n            return;\n          }\n          if (opts.shareRedirect) {\n            window.location = opts.shareRedirect + xhr.responseText;\n          }\n          var path = \"/p/\" + xhr.responseText;\n          var url = origin(window.location) + path;\n\n          for (var i = 0; i < shareCallbacks.length; i++) {\n            shareCallbacks[i](url);\n          }\n          shareCallbacks = [];\n\n          if (shareURL) {\n            shareURL.show().val(url).focus().select();\n\n            if (rewriteHistory) {\n              var historyData = {\"code\": sharingData};\n              window.history.pushState(historyData, \"\", path);\n              pushedEmpty = false;\n            }\n          }\n        }\n      });\n    }\n\n    $(opts.runEl).click(run);\n    $(opts.fmtEl).click(fmt);\n\n    if (opts.shareEl !== null && (opts.shareURLEl !== null || opts.shareRedirect !== null)) {\n      if (opts.shareURLEl) {\n        shareURL = $(opts.shareURLEl).hide();\n      }\n      $(opts.shareEl).click(function() {\n        share();\n      });\n    }\n  }\n\n  window.playground = playground;\n})();\n" +
	"", etag: `"XMPq4HL955s="`})
